/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useMemo } from 'react'
// useGLTF to load GLTF model into the canvas
import { useAnimations, useGLTF } from '@react-three/drei'
import { MeshStandardMaterial, Color, RepeatWrapping, Vector3 } from 'three';
import { useFrame, useGraph } from "@react-three/fiber"
import { TextureLoader } from 'three/src/loaders/TextureLoader'
import { degToRad } from 'three/src/math/MathUtils';

import * as skeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js"

const MODELS_BASEPATH = './models/salmon/'

export default function Model({
  hue,
  saturation,
  lightness,
  uScale,
  vScale,
  textureIndex,
  position = [0, 0, 0],
  modelScale,
  rotation,
  animIndex = 0,
  movementAnim = false,
}) {
  // load textures
  const textureVector = [
    `${MODELS_BASEPATH}meat_textures/0.png`,
    `${MODELS_BASEPATH}meat_textures/1.jpeg`,
    `${MODELS_BASEPATH}meat_textures/2.jpeg`,
    `${MODELS_BASEPATH}meat_textures/3.jpeg`,
    `${MODELS_BASEPATH}meat_textures/4.jpeg`,
    `${MODELS_BASEPATH}meat_textures/5.jpeg`,
    `${MODELS_BASEPATH}meat_textures/6.jpeg`,
    `${MODELS_BASEPATH}meat_textures/7.jpeg`,
  ]

  const texture = new TextureLoader().load(textureVector[textureIndex])
  // change the scale of the texture
  texture.wrapS = RepeatWrapping;
  texture.wrapT = RepeatWrapping;
  texture.repeat.set(uScale, vScale)

  const hslColor = extractColor(hue, saturation, lightness)
  const material = getMaterial(hslColor, texture)
  // const constantMaterial = getConstantMaterial(hslColor)

  // fish face material
  const constantMaterial = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    bumpMap: new TextureLoader().load(`${MODELS_BASEPATH}salmon_textures/Chinook_salmon_bump.png`),
    bumpScale: 0.5,
  })

  // fish meat
  /* const material = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    map: textureVector[0],
  }) */

  // set changing properties of materials
  constantMaterial.color = hslColor
  material.color = hslColor
  /* if (material.map !== textureVector[animIndex]) {
    material.map = textureVector[animIndex]
    console.log("ssss")
  } */

  // change the scale of the texture
  // material.map.wrapS = RepeatWrapping
  // material.map.wrapT = RepeatWrapping
  // material.map.repeat.set(uScale, vScale)

  // eye material
  const eyeMaterial = new MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.8,
    roughness: 0.3
  })

  const myMesh = useRef()
  // select which gltf model to load
  const { scene, animations } = useGLTF(`${MODELS_BASEPATH}salmon.gltf`)
  const clone = useMemo(() => skeletonUtils.clone(scene), [scene])
  const { nodes } = useGraph(clone)

  const { actions, names } = useAnimations(animations, myMesh)
  // console.log(actions)
  // this is executed after the rendering phase
  useEffect(() => {
    // reset and fade in animation after an index has been changed
    actions[names[animIndex]].reset().fadeIn(0.2).play();

    // TODO change animation when turning

    return () => {
      actions[names[animIndex]].fadeOut(0.2);
    };
  }, [actions, names, animIndex])

  // Check the position along the path and trigger animations accordingly
  useFrame(() => {
    const x = myMesh.current.position.x;
    const y = myMesh.current.position.y;

    if (x >= -1 && x < 1) {
      // Play Animation 1 when x is between 0 and 2
      actions[names[0]].play();
    } else if (x >= 2 && x < 4) {
      // Play Animation 2 when x is between 2 and 4
      actions[names[3]].play();
    } else {
      // Default animation when x is outside the specified range
      actions[names[2]].play();
    }
  });

  // widthRadius is how much the fish can move on the x axis
  const widthRadius = 3.5 - position[2]

  // TODO: fix salmon movements and animation

  const radius = 3.5 - position[2] / 4
  const speed = 0.003 /* + Math.abs(position[2]) / 800; */ // Adjust the speed value to control the speed
  const maxHorizontalDistance = 5; // Set the maximum horizontal distance
  const rotationSpeed = 0.2; // Adjust the rotation speed for the 180Â° rotation
  const gradualRotationSpeed = 0.05; // Adjust the gradual rotation speed
  const prevPositionRef = useRef([0, 0, 0]); // Keep track of the previous position

  useEffect(() => {
    // Initial setup with random initial angle
    myMesh.current.userData.theta = Math.random() * Math.PI * 2;
    myMesh.current.userData.rotating = false;

    // Cleanup function
    return () => {
      // Stop any ongoing animations or cleanup resources if needed
    };
  }, []); // Empty dependency array ensures that the effect runs only once

  useFrame(() => {

    // check if speed is greater than 0 to allow movement
    if (speed > 0 && movementAnim) {
      // parameterized equation for the infinity symbol
      const x = radius * Math.sin(myMesh.current.userData.theta);
      const y = radius * Math.sin(myMesh.current.userData.theta) * Math.cos(myMesh.current.userData.theta);

      // Calculate random values based on the position along the path
      const randomX = Math.sin(myMesh.current.userData.theta) * (Math.random() - 0.5) * 0.1; // Adjust the range and intensity
      const randomY = Math.cos(myMesh.current.userData.theta) * (Math.random() - 0.5) * 0.1; // Adjust the range and intensity

      // Update the mesh position with noise
      myMesh.current.position.x = x;
      myMesh.current.position.y = y;

      // Calculate the vector between current and previous positions
      const directionVector = [
        myMesh.current.position.x - prevPositionRef.current[0],
        myMesh.current.position.y - prevPositionRef.current[1],
        myMesh.current.position.z - prevPositionRef.current[2],
      ];

      // Normalize the vector to get the direction
      const length = Math.sqrt(
        directionVector[0] * directionVector[0] +
        directionVector[1] * directionVector[1] +
        directionVector[2] * directionVector[2]
      );
      const normalizedDirection = [
        directionVector[0] / length,
        directionVector[1] / length,
        directionVector[2] / length,
      ];

      // Use lookAt to set the rotation based on the direction
      myMesh.current.lookAt(
        myMesh.current.position.x + normalizedDirection[0],
        myMesh.current.position.y + normalizedDirection[1],
        myMesh.current.position.z + normalizedDirection[2]
      );

      // Calculate the inclination angle (slope) of the curve
      const inclinationAngle = Math.atan2(normalizedDirection[1], normalizedDirection[0]);

      // // Set the rotation around the z-axis based on the inclination angle
      myMesh.current.rotation.z = inclinationAngle * 2.4755;

      // // Update the previous position
      prevPositionRef.current = [myMesh.current.position.x, myMesh.current.position.y, myMesh.current.position.z];

      // // Update angle
      myMesh.current.userData.theta += speed;

      // Reset angle and rotation flag when a full circle is completed
      if (myMesh.current.userData.theta >= Math.PI * 4) {
        myMesh.current.userData.theta = 0;
        myMesh.current.userData.rotating = false;
      }
    }
  });


  return (
    <group ref={myMesh} dispose={null} scale={modelScale} position={position} rotation={rotation} animIndex={animIndex}>
      <group name="Salmon">
        {/* meat, the one which changes texture */}
        <skinnedMesh
          name="Salmon_Meat"
          object={nodes.Salmon_Meat}
          geometry={nodes.Salmon_Meat.geometry}
          material={material}
          skeleton={nodes.Salmon_Meat.skeleton}
        />
        <group name="Salmon_Skin">
          {/* face */}
          <skinnedMesh
            name="Salmon_Mesh"
            object={nodes.Salmon_Mesh}
            geometry={nodes.Salmon_Mesh.geometry}
            material={constantMaterial}
            skeleton={nodes.Salmon_Mesh.skeleton}
          />
          {/* fins */}
          <skinnedMesh
            name="Salmon_Mesh_1"
            object={nodes.Salmon_Mesh_1}
            geometry={nodes.Salmon_Mesh_1.geometry}
            material={constantMaterial}
            skeleton={nodes.Salmon_Mesh_1.skeleton}
          />
          {/* eyes */}
          <skinnedMesh
            name="Salmon_Mesh_2"
            object={nodes.Salmon_Mesh_2}
            geometry={nodes.Salmon_Mesh_2.geometry}
            material={eyeMaterial}
            skeleton={nodes.Salmon_Mesh_2.skeleton}
          />
        </group>
        <primitive object={nodes.Root} />
      </group>
    </group>
  );
}

useGLTF.preload(`${MODELS_BASEPATH}salmon.gltf`)

// assign the color and the map to the meat material
function getMaterial(color, image) {
  return (
    new MeshStandardMaterial({
      color: color,
      map: image,
    })
  )
}

// convert color in HSL mode
function extractColor(hue, saturation, lightness) {
  return new Color("hsl(0, 100%, 100%)")
    .setHSL((hue ?? 0) / 360, (saturation ?? 0) / 100, (lightness ?? 0) / 100)
}