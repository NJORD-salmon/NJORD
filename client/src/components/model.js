/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useMemo, useState } from 'react'
// useGLTF to load GLTF model into the canvas
import { useAnimations, useGLTF } from '@react-three/drei'
import { MeshStandardMaterial, Color, RepeatWrapping } from 'three';
import { useFrame, useGraph, useThree } from "@react-three/fiber"
import { TextureLoader } from 'three/src/loaders/TextureLoader'

import * as skeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js"

const MODELS_BASEPATH = './models/salmon/'

// load textures
const textureVector = []
for (let j = 0; j < 8; j++) {
  textureVector.push(new TextureLoader().load(`${MODELS_BASEPATH}meat_textures/${j}.jpeg`))
}
const bumpMap = new TextureLoader().load(`${MODELS_BASEPATH}salmon_textures/Chinook_salmon_bump.png`)

export default function Model({
  hue,
  saturation,
  lightness,
  uScale,
  vScale,
  textureIndex,
  position = [0, 0, 0],
  modelScale,
  rotation,
  movementAnim = false,
}) {
  // eye material
  const eyeMaterial = new MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.8,
    roughness: 0.3
  })
  // fish face material
  const constantMaterial = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    bumpMap: bumpMap,
    bumpScale: 0.5,
  })
  // fish meat
  const material = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    map: textureVector[0],
  })
  material.map = textureVector[textureIndex]

  const hslColor = extractColor(hue, saturation, lightness)
  // set color of materials
  constantMaterial.color = hslColor
  material.color = hslColor

  // change the scale of the texture
  material.map.wrapS = RepeatWrapping;
  material.map.wrapT = RepeatWrapping;
  material.map.repeat.set(uScale, vScale)


  const myMesh = useRef()
  // keep track of the previous position
  const prevPositionRef = useRef(position)

  // select which gltf model to load
  const { scene, animations } = useGLTF(`${MODELS_BASEPATH}salmon.gltf`)
  const clone = useMemo(() => skeletonUtils.clone(scene), [scene])
  const { nodes } = useGraph(clone)
  const { actions, names } = useAnimations(animations, myMesh)
  console.log(actions)

  // access the viewport dimensions
  const { viewport } = useThree()
  const maxBoundaryX = viewport.width - position[2]
  const minBoundaryX = -maxBoundaryX
  const maxBoundaryY = viewport.height - position[2] / 2
  const minBoundaryY = -maxBoundaryY

  const [animIndex, setAnimIndex] = useState(0);


  useEffect(() => {
    // reset and fade in animation after an index has been changed
    actions[names[animIndex]].reset().fadeIn(0.2).play();

    // TODO change animation when turning

    return () => {
      /* if (actions) {
        actions[names[animIndex]].fadeOut(0.2);
      } */
    };
  }, [actions, names, animIndex])

  // check the position along the path and trigger animations accordingly
  useFrame(() => {
    if (movementAnim) {
      /* if ((myMesh.current.position.x >= maxBoundaryX - 1 && myMesh.current.position.x <= maxBoundaryX - 0.5) ||
        (myMesh.current.position.x <= minBoundaryX + 1 && myMesh.current.position.x >= minBoundaryX + 0.5)) {
        setAnimIndex(6)
      } else if ((myMesh.current.position.x >= maxBoundaryX - 0.5 && myMesh.current.position.x <= maxBoundaryX) ||
        (myMesh.current.position.x <= minBoundaryX + 0.5 && myMesh.current.position.x >= minBoundaryX)) {
        setAnimIndex(5)
      }
      else  */setAnimIndex(0)
      // TODO: fix salmon movements and animation
    }
  })

  // initial movement setup
  useEffect(() => {
    if (movementAnim) {
      myMesh.current.rotation.y = Math.PI / 2

      // TODO: use previous position, if any, to initialize the correct salmon position
      myMesh.current.position.x = prevPositionRef.current[0]
      myMesh.current.position.y = prevPositionRef.current[1]
    }
  }, []);

  const [slow, setSlow] = useState(false)
  const speed = 2.7
  let displacementX = (speed - position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)
  let displacementY = (speed + position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)

  // let directionX = (Math.random() >= 0.5 ? 1 : -1)
  // let directionY = (Math.random() >= 0.5 ? 1 : -1)

  //   let displacementX = (speed - position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)
  //   let displacementY = (speed + position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)
  // let speedX = Math.max(maxBoundaryX - position[0], 0)
  // let speedY = Math.max(maxBoundaryY - position[1], 0)

  useFrame(({ clock }) => {
    if (movementAnim) {
      const t = clock.getElapsedTime()
      /*  speedX = Math.max(maxBoundaryX - myMesh.current.position.x, 0)
       speedY = Math.max(maxBoundaryY - myMesh.current.position.y, 0) */
      /* displacementX = Math.sin()
      displacementY = */

      displacementX = computeChange(
        myMesh.current.position.x,
        displacementX,
        minBoundaryX,
        maxBoundaryX
      )
      displacementY = computeChange(
        myMesh.current.position.y,
        displacementY,
        minBoundaryY,
        maxBoundaryY
      )

      // TODO: find a way to implement rotation at the end


      // normal walk movements
      myMesh.current.position.x += /* directionX *  */displacementX
      myMesh.current.position.y += /* directionY  **/ displacementY


      // to make sure the salmon is oriented as the path it follows
      // calculate the vector between current and previous positions
      const directionVector = [
        myMesh.current.position.x - prevPositionRef.current[0],
        myMesh.current.position.y - prevPositionRef.current[1],
        myMesh.current.position.z - prevPositionRef.current[2],
      ];
      // normalize the vector to get the direction
      const length = Math.sqrt(
        directionVector[0] * directionVector[0] +
        directionVector[1] * directionVector[1] +
        directionVector[2] * directionVector[2]
      );
      const normalizedDirection = [
        directionVector[0] / length,
        directionVector[1] / length,
        directionVector[2] / length,
      ];
      // use lookAt to set the rotation based on the direction
      myMesh.current.lookAt(
        myMesh.current.position.x + normalizedDirection[0] / 1000,
        myMesh.current.position.y + normalizedDirection[1] / 1000,
        myMesh.current.position.z + normalizedDirection[2] / 1000
      );

      // TODO: store the current position as previous position
      prevPositionRef.current = [myMesh.current.position.x, myMesh.current.position.y, myMesh.current.position.z]
    }
  })


  // useFrame(() => {
  //   // check if speed is greater than 0 to allow movement
  //   if (movementAnim) {
  //     const theta = myMesh.current.userData.theta;

  //     // use ImprovedNoise noise to introduce randomness to the path

  //     const noiseX = noiseGenerator.noise(theta * 0.1, 1, 200) * 2
  //     const noiseY = noiseGenerator.noise(1, theta * 0.1, 200) * 2
  //     // console.log(noiseX, noiseY)

  //     // parameterized equation for the infinity symbol
  //     const x = radius * Math.sin(myMesh.current.userData.theta) + noiseX;
  //     const y = radius * Math.sin(myMesh.current.userData.theta) * Math.cos(myMesh.current.userData.theta) + noiseY;

  //     // Update the mesh position with noise
  //     myMesh.current.position.x = x;
  //     myMesh.current.position.y = y;

  //     // to make sure the salmon is oriented as the path it follows
  //     // calculate the vector between current and previous positions
  //     const directionVector = [
  //       myMesh.current.position.x - prevPositionRef.current[0],
  //       myMesh.current.position.y - prevPositionRef.current[1],
  //       myMesh.current.position.z - prevPositionRef.current[2],
  //     ];
  //     // normalize the vector to get the direction
  //     const length = Math.sqrt(
  //       directionVector[0] * directionVector[0] +
  //       directionVector[1] * directionVector[1] +
  //       directionVector[2] * directionVector[2]
  //     );
  //     const normalizedDirection = [
  //       directionVector[0] / length,
  //       directionVector[1] / length,
  //       directionVector[2] / length,
  //     ];
  //     // use lookAt to set the rotation based on the direction
  //     myMesh.current.lookAt(
  //       myMesh.current.position.x + normalizedDirection[0],
  //       myMesh.current.position.y + normalizedDirection[1],
  //       myMesh.current.position.z + normalizedDirection[2]
  //     );
  //     // calculate the inclination angle (slope) of the curve
  //     const inclinationAngle = Math.atan2(normalizedDirection[1], normalizedDirection[0]);
  //     // set the rotation around the z-axis based on the inclination angle
  //     myMesh.current.rotation.z = inclinationAngle * 2.4755;


  //     // update the previous position
  //     prevPositionRef.current = [myMesh.current.position.x, myMesh.current.position.y, myMesh.current.position.z];

  //     // Update angle
  //     myMesh.current.userData.theta += speed;

  //     // Reset angle and rotation flag when a full circle is completed
  //     if (myMesh.current.userData.theta >= Math.PI * 4) {
  //       myMesh.current.userData.theta = 0;
  //       myMesh.current.userData.rotating = false;
  //     }
  //   }
  // });


  return (
    <group ref={myMesh} dispose={null} scale={modelScale} position={position} rotation={rotation} animIndex={animIndex}>
      <group name="Salmon">
        {/* meat, the one which changes texture */}
        <skinnedMesh
          name="Salmon_Meat"
          object={nodes.Salmon_Meat}
          geometry={nodes.Salmon_Meat.geometry}
          material={material}
          skeleton={nodes.Salmon_Meat.skeleton}
        />
        <group name="Salmon_Skin">
          {/* face */}
          <skinnedMesh
            name="Salmon_Mesh"
            object={nodes.Salmon_Mesh}
            geometry={nodes.Salmon_Mesh.geometry}
            material={constantMaterial}
            skeleton={nodes.Salmon_Mesh.skeleton}
          />
          {/* fins */}
          <skinnedMesh
            name="Salmon_Mesh_1"
            object={nodes.Salmon_Mesh_1}
            geometry={nodes.Salmon_Mesh_1.geometry}
            material={constantMaterial}
            skeleton={nodes.Salmon_Mesh_1.skeleton}
          />
          {/* eyes */}
          <skinnedMesh
            name="Salmon_Mesh_2"
            object={nodes.Salmon_Mesh_2}
            geometry={nodes.Salmon_Mesh_2.geometry}
            material={eyeMaterial}
            skeleton={nodes.Salmon_Mesh_2.skeleton}
          />
        </group>
        <primitive object={nodes.Root} />
      </group>
    </group>
  );
}

useGLTF.preload(`${MODELS_BASEPATH}salmon.gltf`)

// convert color in HSL mode
function extractColor(hue, saturation, lightness) {
  return new Color("hsl(0, 100%, 100%)")
    .setHSL((hue ?? 0) / 360, (saturation ?? 0) / 100, (lightness ?? 0) / 100)
}

function computeChange(value, displacement, minBoundary, maxBoundary) {
  if ((value > maxBoundary && displacement > 0) || (value < minBoundary && displacement < 0)) {
    return displacement * -1
  }

  return displacement
}