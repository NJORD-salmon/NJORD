/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useMemo, useState } from 'react'
// useGLTF to load GLTF model into the canvas
import { useAnimations, useGLTF } from '@react-three/drei'
import { MeshStandardMaterial, Color, RepeatWrapping } from 'three';
import { useFrame, useGraph, useThree } from "@react-three/fiber"
import { TextureLoader } from 'three/src/loaders/TextureLoader'

import * as skeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js"
import { degToRad } from 'three/src/math/MathUtils';

const MODELS_BASEPATH = './models/salmon/'

// load textures
const textureVector = []
for (let j = 0; j < 9; j++) {
  textureVector.push(new TextureLoader().load(`${MODELS_BASEPATH}meat_textures/${j}.png`))
}
const skinBumpMap = new TextureLoader().load(`${MODELS_BASEPATH}salmon_textures/salmon_skin_bump.png`)
const finBumpMap = new TextureLoader().load(`${MODELS_BASEPATH}salmon_textures/salmon_fin_bump.png`)

export default function Model({
  hue,
  saturation,
  lightness,
  uScale,
  vScale,
  textureIndex,
  position = [0, 0, 0],
  modelScale,
  rotation,
  animIndex = 0,
  isAnimChanging = false,
  currentState,
  movementAnim = false,
  idx,
}) {
  const myMesh = useRef()
  // keep track of the previous position
  const prevPositionRef = useRef(position)
  const [isFirstFrame, setIsFirstFrame] = useState(true)
  let startMoving = movementAnim
  let isEntering = false

  // eye material
  const eyeMaterial = new MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.8,
    roughness: 0.3
  })
  // fish face material
  const skinMaterial = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    bumpMap: skinBumpMap,
    bumpScale: 0.4,
  })
  // fins material
  const finsMaterial = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    bumpMap: finBumpMap,
    bumpScale: 0.9,
  })
  finsMaterial.bumpMap.rotation = degToRad(-8)
  finsMaterial.bumpMap.repeat.set(0.5, 0.5)
  // fish meat
  const material = new MeshStandardMaterial({
    color: extractColor(6, 93, 60),
    map: textureVector[4],
  })
  material.map = textureVector[textureIndex]

  const hslColor = extractColor(hue, saturation, lightness)
  // set color of materials
  skinMaterial.color = hslColor
  finsMaterial.color = hslColor
  material.color = hslColor

  // change the scale of the texture
  material.map.wrapS = RepeatWrapping;
  material.map.wrapT = RepeatWrapping;
  material.map.repeat.set(uScale, vScale)

  // select which gltf model to load
  const { scene, animations } = useGLTF(`${MODELS_BASEPATH}salmon.gltf`)
  const clone = useMemo(() => skeletonUtils.clone(scene), [scene])
  const { nodes } = useGraph(clone)
  const { actions, names } = useAnimations(animations, myMesh)

  // access the viewport dimensions
  const { viewport } = useThree()
  const maxBoundaryX = viewport.width - position[2]
  const minBoundaryX = -maxBoundaryX
  const maxBoundaryY = viewport.height - position[2] / 2
  const minBoundaryY = -maxBoundaryY

  useEffect(() => {
    // reset and fade in animation after an index has been changed
    actions[names[animIndex]].reset().fadeIn(0.5).play()
    if (isAnimChanging) {
      // in the clean-up phase, fade it out
      return () => actions[names[animIndex]].fadeOut(0.5)
    }
  }, [animIndex, isAnimChanging])

  // TODO?: check the position along the path and trigger animations accordingly
  useFrame(() => {
    if (movementAnim) {
      //     if ((myMesh.current.position.x >= maxBoundaryX - 1 && myMesh.current.position.x <= maxBoundaryX - 0.5) ||
      //       (myMesh.current.position.x <= minBoundaryX + 1 && myMesh.current.position.x >= minBoundaryX + 0.5)) {
      //       setAnimIndex(6)
      //     } else if ((myMesh.current.position.x >= maxBoundaryX - 0.5 && myMesh.current.position.x <= maxBoundaryX) ||
      //       (myMesh.current.position.x <= minBoundaryX + 0.5 && myMesh.current.position.x >= minBoundaryX)) {
      //       setAnimIndex(5)
      //     }
      //     else 
      //     setAnimIndex(0)
    }
  })


  // let lookAtX = 0
  // let lookAtY = 0
  // let changeX = 0.01
  // let changeLookAtX = 0.01
  // let salmonDirection = 1
  // let lookAtDirection = 1
  // let moveSalmon = true

  // initial movement setup
  useEffect(() => {
    if (startMoving) {
      myMesh.current.rotation.y = Math.PI / 2

      // TODO: use previous position, if any, to initialize the correct salmon position
      myMesh.current.position.x = prevPositionRef.current[0] /* + changeX */
      myMesh.current.position.y = prevPositionRef.current[1]

      // let normalizedDirection = -computeNormalizedDirection(myMesh.current.position, prevPositionRef)
      // salmonDirection = (normalizedDirection > 0) ? -1 : 1

      // myMesh.current.lookAt(
      //   // myMesh.current.position.x + 1,
      //   lookAtX + normalizedDirection[0] / 1000,
      //   // myMesh.current.position.x + 0.001,
      //   lookAtY + normalizedDirection[1] / 1000,
      //   myMesh.current.position.z
      // )


      // delay to add new salmon in aquarium
      if (currentState == "DISPLAY") {
        if (idx !== 0) {
          startMoving = false
          setTimeout(() => {
            startMoving = true
          }, 3300);
        } else {
          isEntering = true
          //   startMoving = false
          //   setTimeout(() => {
          //     isEntering = false
          //   }, 2500);
          setTimeout(() => {
            // startMoving = true
            isEntering = false
          }, 3300)
        }
      }
    }
  }, [currentState, startMoving]);

  const speed = 2.7
  let displacementX = (speed - position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)
  let displacementY = (speed + position[2]) / 1000 * (Math.random() >= 0.5 ? 1 : -1)

  let lastPosition
  const n = 0.5

  useFrame(({ clock }) => {
    let t = clock.elapsedTime
    if (isEntering) {
      // myMesh.current.position.y -= 0.01
      //myMesh.current.position.y += 
    }
    // first frame to orient the fishes (then wait before starting moving)
    if (startMoving || (isFirstFrame && currentState === 'DISPLAY')) {
      setIsFirstFrame(false)

      /*  speedX = Math.max(maxBoundaryX - myMesh.current.position.x, 0)
       speedY = Math.max(maxBoundaryY - myMesh.current.position.y, 0) */
      /* displacementX = Math.sin()
      displacementY = */

      // normal walk movements
      myMesh.current.position.x += /* directionX *  */displacementX
      myMesh.current.position.y += /* directionY  **/ displacementY


      // TODO: find a way to implement rotation at the end


      const normalizedDirection = calculateNormalVector(myMesh.current.position, prevPositionRef)
      if (myMesh.current.position.y >= minBoundaryY + 2) {
        lastPosition = myMesh.current.position.x
      }

      /* if (myMesh.current.position.y < minBoundaryY + 2) {
        const theta = calculateAngle(normalizedDirection, [1, 0, 1])

        console.log(myMesh.current.position.y)
        myMesh.current.position.y = parabola(n, myMesh.current.position.x, lastPosition, theta, -viewport.height + n)
        console.log(myMesh.current.position.y)
      } else { */

      displacementX = computeChange(
        myMesh.current.position.x,
        displacementX,
        minBoundaryX,
        maxBoundaryX
      )
      displacementY = computeChange(
        myMesh.current.position.y,
        displacementY,
        minBoundaryY,
        maxBoundaryY
      )
      // }

      // to make sure the salmon is oriented as the path it follows    
      // use lookAt to set the rotation based on the direction
      myMesh.current.lookAt(
        myMesh.current.position.x + normalizedDirection[0] / 1000,
        myMesh.current.position.y + normalizedDirection[1] / 1000,
        myMesh.current.position.z + normalizedDirection[2] / 1000
      );

      // TODO: store the current position as previous position
      prevPositionRef.current = [myMesh.current.position.x, myMesh.current.position.y, myMesh.current.position.z]

    }
  })

  return (
    <group ref={myMesh}
      dispose={null}
      scale={modelScale}
      position={position}
      rotation={rotation}
      animIndex={animIndex}
    >
      <group name="Salmon">
        {/* eyes */}
        <skinnedMesh
          name="Salmon_Eye"
          geometry={nodes.Salmon_Eye.geometry}
          material={eyeMaterial}
          skeleton={nodes.Salmon_Eye.skeleton}
        />
        {/* fins */}
        <group name="Salmon_Fins">
          <skinnedMesh
            name="Salmon_Mesh001"
            geometry={nodes.Salmon_Mesh001.geometry}
            material={finsMaterial}
            skeleton={nodes.Salmon_Mesh001.skeleton}
          />
          <skinnedMesh
            name="Salmon_Mesh001_1"
            geometry={nodes.Salmon_Mesh001_1.geometry}
            material={finsMaterial}
            skeleton={nodes.Salmon_Mesh001_1.skeleton}
          />
        </group>
        {/* meat, the one which changes texture */}
        <skinnedMesh
          name="Salmon_Meat"
          geometry={nodes.Salmon_Meat.geometry}
          material={material}
          skeleton={nodes.Salmon_Meat.skeleton}
        />
        {/* face */}
        <skinnedMesh
          name="Salmon_Skin"
          geometry={nodes.Salmon_Skin.geometry}
          material={skinMaterial}
          skeleton={nodes.Salmon_Skin.skeleton}
        />
        <primitive object={nodes.Root} />
      </group>
    </group>
  );
}

useGLTF.preload(`${MODELS_BASEPATH}salmon.gltf`)

// convert color in HSL mode
function extractColor(hue, saturation, lightness) {
  return new Color("hsl(0, 100%, 100%)")
    .setHSL((hue ?? 0) / 360, (saturation ?? 0) / 100, (lightness ?? 0) / 100)
}

function computeChange(value, displacement, minBoundary, maxBoundary) {
  if ((value > maxBoundary && displacement > 0) || (value < minBoundary && displacement < 0)) {
    return displacement * -1
  }

  return displacement
}

function parabola(n, position, lastPosition, theta, h) {
  let a = Math.pow(Math.cos(theta), 2) / (2 * n * Math.pow(Math.sin(theta), 2))
  let b = - (Math.cos(theta) / Math.sin(theta)) * (((lastPosition * Math.cos(theta)) / (n * Math.sin(theta))) + 1)
  let c = h - a * Math.pow(lastPosition, 2) - b * lastPosition

  let displacement = a * Math.pow(position, 2) + b * position + c

  return displacement
}

function calculateAngle(a, b) {
  // dot product with vertical vector  b [0, 1, 0]
  const dot = dotProduct(a, b)
  const angle = Math.acos(dot);

  return angle;
}

function dotProduct(vector1, vector2) {
  let result = 0;
  for (let i = 0; i < vector1.length; i++) {
    result += vector1[i] * vector2[i];
  }
  return result;
}

function calculateNormalVector(position, prevPositionRef) {
  // calculate the vector between current and previous positions
  const directionVector = [
    position.x - prevPositionRef.current[0],
    position.y - prevPositionRef.current[1],
    position.z - prevPositionRef.current[2],
  ];
  // normalize the vector to get the direction
  const length = Math.sqrt(
    directionVector[0] * directionVector[0] +
    directionVector[1] * directionVector[1] +
    directionVector[2] * directionVector[2]
  );
  const normalizedDirection = [
    directionVector[0] / length,
    directionVector[1] / length,
    directionVector[2] / length,
  ];
  return normalizedDirection
}